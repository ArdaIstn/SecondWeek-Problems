Q1) val ile var arasındaki fark nedir ?

Answer1:En basit tanımıyla,val ile tanımladığımız bir değişkenin değerini sonradan değiştiremeyiz fakat var ile tanımladığımız bir değişkenin değerini sonradan değiştirebiliriz.Aslında var(variable),val(value) şeklinde düşünebiliriz.Ek olarak val değişkenlere immutable denildiğini duyarız fakat bu yanlış bir tabirdir.Aslında val değişkenler readOnly değişkenlerdir.İkisinin de tanımına bakalım.ReadOnly demek değeri okunabilen,ilk değer atamasından sonra tekrar değer atanamayan(set edilemeyen) değişkenlerdir.Fakat immutable demek ise bir değişkenin/nesnenin durumu asla ilk değerden farklı olamaz demektir.Bunu aslında bir örnek vererek açıklamak istiyorum.

fun main() {
    val o1 = SumCalculations()
    println("Result1:${o1.result}")

    o1.number1 = 30
    o1.number2 = 40
    o1.number3 = 50

    println("Result2:${o1.result}")

    o1.number1 = 50
    o1.number2 = 60
    o1.number3 = 70

    println("Result3:${o1.result}")
}

class SumCalculations {
    var number1 = 10
    var number2 = 20
    var number3 = 30

    val result: Int
        get() {
            return number1 + number2 + number3
        }

}
Yukarıdaki örneğimize baktığımızda classın içerisine 3 adet var değişken tanımladım.Val olarak da result değişkeni tanımlayıp get fonksiyonuna return diyip,3 adet number'ın toplamını döndürdüm.Bu durumda classın dışında,ben bu classtan bir nesne oluşturduğumda ve number değişkenlerinin değerlerini değiştiriğimde otomatik olarak da val olarak tanımladığım result değerinin döndürdüğü değer değişecektir.Bundan dolayı result değişkeni immutable değil,readonlydir.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q2) Bir var değişkeni val gibi davranmasını nasıl sağlayabiliriz val kelimesini kullanmadan? Bunu neden yapmak isteriz? Örnek bir senaryo verin.

Answer2:Bir var değişkeni val keywordunu kullanmadan val gibi davranmasını sağlamak için o değişkenin class içerisinde set fonksiyonunu private yapmamız gerekir.İlerleyen konularda göreceğiz fakat bizim aslında değişken diye tanımladığımız şeyler birer propertydir.Bu propertylerde de basitçe o değişkenin get ve set fonksiyonlarıdır.Yani biz bir değişken tanımladığımızda ve imleçi üzerine getirdiğimizde zaten genelde property ile ilgili bir yazı görürüz.Biz  var keywordu ile bir değişken tanımladığımızda örneğin,var name : String = "Arda",bu değişkenin arka planda get ve set fonksiyonları oluşur.Bu değişkeni val ile tanımlarsam arka planda sadece get fonksiyonu oluşur,set fonksiyonu  oluşmaz.Bu konuyu property vs field kısmında daha net anlayacağız fakat ben burda kısaca bahsetmek istedim.Sorumuza dönecek olursak değişkenin set fonksiyonunu private yaparsak bu durumda değişkene dışarıdan sadece erişebiliriz fakat değerini değiştiremeyiz.Bu kullanımı class içerisinde değerini değiştirmek istediğim bir değişken varsa ve ben bu değişkenin değerinin dışarıdan değiştirilmemesini istiyorsam kullanabilirim.

fun main() {
    val user = MyUser()
    user.surname = ""(Cannot assign to 'surname': the setter is private in 'MyUser' hatası alırız.)

}


class MyUser() {
    var name: String = "Arda"

    var surname: String = "Işıtan"
        private set


    fun changeSurname() {
        surname = "kaya" Class içerisinde değeri değiştirilebilir fakat class dışında değeri değiştirilemez.
    }
}


---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Q3) Değişmez" (Immutable) ve "Salt Okunur" (ReadOnly) kavramlarını açıklayın. val değişkenler neden aslında "değişmez" değil de "salt okunur" olarak açıklanmalıdır?

Answer3: İlk soruda da bahsettiğim gibi,ben de bu zamana kadar val değişkenlerin immutable olduğunu biliyordum.Fakat aslında bu tanım yanlış bir tanımdır.val değişkenler readonlydir.İmmutable demek bir değişkenin veya nesnenin durumunun asla ilk değerden farklı olamamasıdır.Readonly ise,bir değişkenin değerinin okunabilmesi ve ilk değer atamasından sonra tekrar değer atanamaması(set edilememesi) anlamına gelir.

fun main() {
    val country = Country()
    country.print()

}

class Country {
    private var varMyCountry: String = "Turkey"
    private val valMyCountry: String
        get() {
            return varMyCountry
        }

    fun print() {
        println(valMyCountry)
        varMyCountry = "Spain"
        println(valMyCountry)
        varMyCountry = "Italy"
        println(valMyCountry)
    }
    
}

Yukarıdaki örnekte çıktılar sırasıyla,"Turkey","Spain","Italy" şeklinde olur.Bu şekilde class içerisinde val ile tanımladığımız bir val property'nin değerini değiştirebiliyoruz.İmmutable olması için getter fonksiyonunu değiştiremememiz gerekiyor.Bunu yapmak için de val değişkenleri bir fonksiyon scoopu içerisinde tanımlarsak,arka planda getter ve setter fonksiyonları oluşmayacaktır bu durumda da immutable olacaktır.



--------------------------------------------------------------------------------------------------------------------------------------------------------------------


Q4) Tip Çıkarımı" (Type inference) kavramını açıklayın. Hangi durumlarda tip belirtmek kesin olarak gereklidir?

Answer4:Tip çıkarımı,değişkenlerin tipinin aldığı değere göre otomatik olarak belirlenmesidir.Örneğin biz var name = "Arda" dediğimizde,IDE otomatik olarak name değişkeninin tipini string set eder,çünkü aldığı değer stringdir.Eğer değişkenimizi bir class içerisinde tanımlıyorsak bir değer ataması yapmamız gerekir.Fakat eğer local olarak bir fonksiyonun içerisinde bir değişken tanımlıyorsak o zaman değişkeninin tipini kesin olarak belirtmemiz gerekir.

fun main() {

var name : String (Bu şekilde başlangıç değer olmadan local bir değişken tanımlayabiliyoruz)

}
class Deneme(){

    val age : Int (Bu şekilde tanımlayamayız,bir değer atamamız gerekir.)

}


--------------------------------------------------------------------------------------------------------------------------------------------------------------------


Q5)Kotlin'de tüm değişkenlerin sınıf olarak bulunması, "ilkel tip" (primitive type) olmadıkları anlamına gelir mi? Arka planda neler oluyor?

Answer5:Kotlinde tüm değişkenler sınıf olarak tutulur, ilgili veri tipinin üzerine ctrl ile tıklayarak bakabiliriz.Fakat bu sınıflar,bytecode'a çevrilirken yapılan özel optimizasyonlarla primitive hallerine dönüştürülürler.Yani aslında kotlinde Int class olarak tutulan veriler,arka planda int olarak tutulur.Bu String hariç bütün değişkenlerde böyledir.String,java tarafında da class halinde tutulur.



--------------------------------------------------------------------------------------------------------------------------------------------------------------------


Q6)"Tip Güvenliği" (Type Safety) kavramını açıklayın.

Answer6:Kotlin'de "type safety" veya "tür güvenliği", bir programın türlerle ilişkili hataları minimuma indirmesini sağlayan bir özelliktir. Bu, kotlinin  tür sistemi tarafından sağlanır ve bizim  veri türlerini doğru ve güvenli bir şekilde kullanılmasını sağlar.Bu aslında bizim kod yazarken daha güvenli ve sağlam kod yazmamızı sağlar.Kotlin,tür güvenliğini çeşitli yollardan sağlar.Null güvenliği,tür çıkarımı,type checks,smart cast gibi özelliklerle kodumuzu minimum hatada yazarız.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------


Q7)Bir değişkeni nullable yapmak için ne yapmalıyız?


Answer7:Kotlinde bir değişkeni nullable yapmak için,değişkenin tipinin sonuna ? koymamız gerekir.Bu,değişkenin null değerini de alabileceği anlamına gelir.Hemen bir örnekle açıklayalım.

fun main() {

    var nullableString : String? = null

}

Yukarıdaki örnekte,nullableString değişkeni string türünde olmasına rağmen null değerini de alabilir çünkü nullable(?) tanımlanmıştır.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------


Q8)"Null Güvenliği" (Null Safety) kavramını açıklayın.

Answer8: Kotlinde bulunan null safety,uygulama geliştirirken null referans hatalarını önlemeyi amaçlayan bir özelliktir.Null referans hataları genellikle bir nesne veya değişken  null olduğunda ya da o nesne veya değişken üzerinden bir işlem yapmaya çalıştığımızda meydana gelir.Bu tür hataları aldığımızda genellikle hata ayıklama süreçlerimiz karmaşıklaşır ve uygulamada beklenmeyen davranışlara yol açabilir.Kotlinde null güvenliğini çeşitli yollardan sağlayabiliriz.Bunlara ?. veya !!. kullanımı,elvis operatörünün kullanımı,let fonksiyonunu kullanımı gibi çeşitli örnekler verilebilir.



--------------------------------------------------------------------------------------------------------------------------------------------------------------------



Q9)Bir değişkene null değer atanır ve tip belirtilmezse Kotlin bu değişkeni nasıl yorumlar?

Answer9: Bir değişkene null değeri atayıp o değişkenin tipini belirtmezsek kotlin bu değişkenin tipini Nothing? olarak belirler.Nothing aslında bomboş bir classtır.Nothing? sadece null değer alabilir ve başka hiçbir değeri temsil etmez.


--------------------------------------------------------------------------------------------------------------------------------------------------------------------


Q10)İlkel bir değişkenin nullable olması ile null değer alamaması arasında bellek yönetimi açısından nasıl farklar vardır?

Answer10 : Bizim stack ve heap denen 2 adet memory alanımız vardır.Biz bir primitive(ilkel)  değişken tanımladığımız zaman hem değişkenin kendisi hem de değişkenin değeri stack alanında tutulur.Stack alanı heap alanından daha hızlı çalışır.Fakat biz referans tipli bir değişkenle çalışıyorsak,değişkenin kendisi stack alanında,değeri ise heap alanında tutulur.Primitive bir değişkeni nullable yaparsak,bu değişken artık primitive tip gibi değil,büyük class tiplerine dönüşür.Örneğin val age : Int? yazıp herhangi bir değer atarsak,age değişkeninin kendisi stackde,değeri ise heapde tutulur.


--------------------------------------------------------------------------------------------------------------------------------------------------------------------



Q11)Nullable bir değişkenin bir değere sahip olması ile null olması arasında bellek yönetimi açısından nasıl bir fark vardır? Null değer almış bir değişken bellekte yer kaplamaz diyebilir miyiz?


Answer11:Nullable bir değişkenin bir değere sahip olması demek,değişkenin kendisinin stack alanında,değerinin ise heap alanında tutulduğu anlamına gelir.Null olması demek ise o değişkenin kendisinin stack alanında tutulması fakat heap'de kullandığı alanın boşalması demektir.Bu bakımdan null değer almış bir değişken bellekte yer kaplamaz diyemeyiz.Çünkü o değişkenin null değer alması heapdeki alanının boşalmasına sebep olur fakat değişkenin ismi  stack alanında tutulmaya devam edilir.Sonrasında null yerine bir değer atarsak,heap'de değişkenin değeri stack'de ise değişkenin kendisi tutulmaya devam edilir.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------



Q12)Nullable bir değişkenle çalışırken hangi operatörleri kullanırız? Bu operatörlerin kullanım farkları nelerdir? Hangisini ne zaman kullanmak daha anlamlıdır?

Answer12: Nullable değişkenlerle çalışırken ?.(Safe call operatörü) veya !!.(Non-null Assert Operatörü) operatörlerini kullanırız. 

?. operatörü,nullable değişkenler üzerinde işlem yaparken,null değerlerini güvenli bir şekilde işlemek için kullanılır.Örneğin val name:String? = "Arda" bu ifade nullable bir ifadedir.println(name?.length()) dediğimizde name değişkeni null ise bu işlemi gerçekleştirmeyecek ve null yazısını ekranda bastıracaktır.Fakat eğer name ifadesi buradaki gibi null değilse işlemi gerçekleştirecek ve ekrana 4 yazısını bastıracaktır.Yani sonuç olarak değişken null ise null değerini döndür,eğer null değil ise verilen işlemi gerçekleştir diyoruz.

!!. operatöründe ise nullable bir değişkenin null olmayacağının garantisini vermiş oluruz.Bu durumda eğer değişken null ise NullPointerException hatası fırlatılır.Bu örnekten gidecek olursak println(name!!.length()) dediğimiz zaman name değişkeni kesinlikle null değil demiş oluruz ve bu işlemden hata almayız.Fakat name değişkeninin değerini null yaparsak,bahsettiğim üzere NullPointerException hatası alırız.

Best Practice olarak kodlarımızı !!. şeklinde yazmamız NullPointerException hatası almamızı sağlar,bu sayede gözden kaçan nullable değerleri bulabilmemizi sağlar.
Ancak,canlıya çıkan projemiz var ise,çok gerekli olmayan kısımlar yani daha az önemli olan kısımlar için ?. kullanımını,daha önemli olan,daha kritik olan yani uygulamanın crash olması kullanıcıya hatalı bilgi göstermekten daha önemliyse !!. kullanımını yapmamız daha uygun olacaktır.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

                                                                            NUMBERS 


Q1)Kaç farklı tipte "number" sınıfı miras alan "alt sınıf" (child class) vardır? Bunların değer aralıkları neden önemlidir?

Answer1:Number classını miras alan child  classlar:Byte,Short,Int,Long,Double ve Float classlarıdır.Bu veri tiplerinin değerleri bizim için önemlidir çünkü bu veri tiplerinin alabileceği belli değer aralıkları vardır.Belli değer aralıklarını almalarının dışında hepsi bellekte farklı boyutlarda yer kaplarlar.Örneğin Byte veri tipi bellekte 8 bitlik yer kaplar ve (-128)-(127) değer aralığına sahip değerleri alabilir.Projelerimizde maksimum performansı alabilmek için,veri tiplerinin değer aralıklarına uygun bir şekilde çalışmalıyız.Örneğin daha büyük sayıları temsil etmek için Long veri tipini veya daha küçük sayıları temsil etmek için Byte veya Short veri tipini kullanmalıyız.Ayrıca bu veri tiplerini kullanırken de değer aralıklarını aşmamaya dikkat etmeliyiz.



--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q2)Eğer bir değişkene tip belirtimi yapılmaz ve bir değer atanırsa, Kotlin tip çıkarımını nasıl yapar?

Answer2: 3 adet değişken tanımladığımızı düşünelim.Bunlardan birisi "Arda",diğeri true diğeri ise 'a' değerini alsın.Kotlinde default olarak veri tipleri sırasıyla String,Boolean ve Char olacaktır.Fakat sayılarda bu durum biraz farklıdır.Sayılarda eğer atanılan değer Int'ın değer aralığından büyük değil ise değişkenin tipi otomatik olarak Int set edilir.Öbür taraftan eğer atanılan değer Int'ın değer aralığından büyük ise değişkenin tipi otomatik olarak Long set edilir.



--------------------------------------------------------------------------------------------------------------------------------------------------------------------


Q3)Float değişken oluştururken F ve f harfleri varken, Long değişken oluştururken neden küçük l harfi yoktur?


Answer3: Kotlinde long bir değişken oluştururken L harfini kullanırız.Küçük l harfinin olmama nedeni ise,küçük l harfi,bazı fontlar ve editörlerde küçük 1(bir) karakteriyle karışabilir.Bu karışıklık,kodun anlaşılabilirliğini azaltabilir ve bazı hatalara yol açabilir.Bu nedenle L harfinin kullanımı tercih edilmiştir.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------



Q4)Tek duyarlıklı (Single precision) ve Çift duyarlıklı (Double precision) kavramlarını açıklayın.

Answer4 : Tek duyarlıklı sayılar genellikle 32 bitlik kayan nokta formatını temsil ederler.Bu format,bir kayan nokta sayısının yaklaşık olarak 6-7 digit kesinliğe sahip bir şekilde saklar.Daha az bellek kullanır ve daha hızlı işlem yapar,ancak daha düşük hassasiyete sahiptirler.

Çift duyarlıklı sayılar genellikle 64 bitlik kayan nokta formatını temsil ederler.Bu format,bir kayan nokta sayısının yaklaşık olarak 15-16 digit kesinliğe sahip bir şekilde saklar.Daha fazla bellek kullanır ve daha yavaş işlem yapar,ancak daha yüksek hassasiyete sahiptir.

Kotlinde ise double ve float denen 2 adet kayan noktaları temsil eden veri tipleri bulunmaktadır.Kotlin'de varsayılan olarak ondalıklı sayılar double tanımlanır ve çift duyarlıklı sayılardır.Double genellikle daha yüksek hassasiyet gerektiren işlemlerde kullanılır,fakat daha fazla bellek kullanırlar.Değişkenin değerinin sonunda 'f' veya 'F' koyar isek float bir ondalıklı sayı tanımlamış oluruz.Bunlar ise tek duyarlıklı sayılardır.Float veri tipini,belli durumlarda bellek kullanımını azaltmak veya daha hızlı işlem yapabilmek için tercih edebiliriz.


--------------------------------------------------------------------------------------------------------------------------------------------------------------------


Q5)Double ve Float değişkenlerle çalışırken ondalık ayıracı olarak hangi işaretler kullanılır? Bu ayıraçların kullanımında nelere dikkat etmek gerekir?


Answer5: Double ve float değişkenlerle çalışırken,ondalık ayrıracı olarak (.) kullanılır.Örnek olarak aşağıdaki değişkenlere bakabiliriz.

val doubleNumber: Double = 3.14
val floatNumber: Float = 3.14f

Bu ayıracı kullanırken ondalık kısımları ayırırken sadece .(nokta) koymalıyız.Virgül veya başka bir işaret kullanmamalıyız.Bazı dillerde ondalıklı sayıların ondalıklı kısmını ayrırken .(nokta) yerine ,(virgül) kullanılmaktadır.Bu gibi durumlarda dil değişikliği yaparken dikkat etmeliyiz.


--------------------------------------------------------------------------------------------------------------------------------------------------------------------


