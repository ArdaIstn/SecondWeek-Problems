Q1) val ile var arasındaki fark nedir ?

Answer1:En basit tanımıyla,val ile tanımladığımız bir değişkenin değerini sonradan değiştiremeyiz fakat var ile tanımladığımız bir değişkenin değerini sonradan değiştirebiliriz.Aslında var(variable),val(value) şeklinde düşünebiliriz.Ek olarak val değişkenlere immutable denildiğini duyarız fakat bu yanlış bir tabirdir.Aslında val değişkenler readOnly değişkenlerdir.İkisinin de tanımına bakalım.ReadOnly demek değeri okunabilen,ilk değer atamasından sonra tekrar değer atanamayan(set edilemeyen) değişkenlerdir.Fakat immutable demek ise bir değişkenin/nesnenin durumu asla ilk değerden farklı olamaz demektir.Bunu aslında bir örnek vererek açıklamak istiyorum.

fun main() {
    val o1 = SumCalculations()
    println("Result1:${o1.result}")

    o1.number1 = 30
    o1.number2 = 40
    o1.number3 = 50

    println("Result2:${o1.result}")

    o1.number1 = 50
    o1.number2 = 60
    o1.number3 = 70

    println("Result3:${o1.result}")
}

class SumCalculations {
    var number1 = 10
    var number2 = 20
    var number3 = 30

    val result: Int
        get() {
            return number1 + number2 + number3
        }

}
Yukarıdaki örneğimize baktığımızda classın içerisine 3 adet var değişken tanımladım.Val olarak da result değişkeni tanımlayıp get fonksiyonuna return diyip,3 adet number'ın toplamını döndürdüm.Bu durumda classın dışında,ben bu classtan bir nesne oluşturduğumda ve number değişkenlerinin değerlerini değiştiriğimde otomatik olarak da val olarak tanımladığım result değerinin döndürdüğü değer değişecektir.Bundan dolayı result değişkeni immutable değil,readonlydir.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q2) Bir var değişkeni val gibi davranmasını nasıl sağlayabiliriz val kelimesini kullanmadan? Bunu neden yapmak isteriz? Örnek bir senaryo verin.

Answer2:Bir var değişkeni val keywordunu kullanmadan val gibi davranmasını sağlamak için o değişkenin class içerisinde set fonksiyonunu private yapmamız gerekir.İlerleyen konularda göreceğiz fakat bizim aslında değişken diye tanımladığımız şeyler birer propertydir.Bu propertylerde de basitçe o değişkenin get ve set fonksiyonlarıdır.Yani biz bir değişken tanımladığımızda ve imleçi üzerine getirdiğimizde zaten genelde property ile ilgili bir yazı görürüz.Biz  var keywordu ile bir değişken tanımladığımızda örneğin,var name : String = "Arda",bu değişkenin arka planda get ve set fonksiyonları oluşur.Bu değişkeni val ile tanımlarsam arka planda sadece get fonksiyonu oluşur,set fonksiyonu  oluşmaz.Bu konuyu property vs field kısmında daha net anlayacağız fakat ben burda kısaca bahsetmek istedim.Sorumuza dönecek olursak değişkenin set fonksiyonunu private yaparsak bu durumda değişkene dışarıdan sadece erişebiliriz fakat değerini değiştiremeyiz.Bu kullanımı class içerisinde değerini değiştirmek istediğim bir değişken varsa ve ben bu değişkenin değerinin dışarıdan değiştirilmemesini istiyorsam kullanabilirim.

fun main() {
    val user = MyUser()
    user.surname = ""(Cannot assign to 'surname': the setter is private in 'MyUser' hatası alırız.)

}


class MyUser() {
    var name: String = "Arda"

    var surname: String = "Işıtan"
        private set


    fun changeSurname() {
        surname = "kaya" Class içerisinde değeri değiştirilebilir fakat class dışında değeri değiştirilemez.
    }
}


---------------------------------------------------------------------------------------------------------------------------------------------------------------------


Q3) Değişmez" (Immutable) ve "Salt Okunur" (ReadOnly) kavramlarını açıklayın. val değişkenler neden aslında "değişmez" değil de "salt okunur" olarak açıklanmalıdır?

Answer3: İlk soruda da bahsettiğim gibi,ben de bu zamana kadar val değişkenlerin immutable olduğunu biliyordum.Fakat aslında bu tanım yanlış bir tanımdır.val değişkenler readonlydir.İmmutable demek bir değişkenin veya nesnenin durumunun asla ilk değerden farklı olamamasıdır.Readonly ise,bir değişkenin değerinin okunabilmesi ve ilk değer atamasından sonra tekrar değer atanamaması(set edilememesi) anlamına gelir.

fun main() {
    val country = Country()
    country.print()

}

class Country {
    private var varMyCountry: String = "Turkey"
    private val valMyCountry: String
        get() {
            return varMyCountry
        }

    fun print() {
        println(valMyCountry)
        varMyCountry = "Spain"
        println(valMyCountry)
        varMyCountry = "Italy"
        println(valMyCountry)
    }
    
}

Yukarıdaki örnekte çıktılar sırasıyla,"Turkey","Spain","Italy" şeklinde olur.Bu şekilde class içerisinde val ile tanımladığımız bir val property'nin değerini değiştirebiliyoruz.İmmutable olması için getter fonksiyonunu değiştiremememiz gerekiyor.Bunu yapmak için de val değişkenleri bir fonksiyon scoopu içerisinde tanımlarsak,arka planda getter ve setter fonksiyonları oluşmayacaktır bu durumda da immutable olacaktır.



--------------------------------------------------------------------------------------------------------------------------------------------------------------------


Q4) Tip Çıkarımı" (Type inference) kavramını açıklayın. Hangi durumlarda tip belirtmek kesin olarak gereklidir?

Answer4:Tip çıkarımı,değişkenlerin tipinin aldığı değere göre otomatik olarak belirlenmesidir.Örneğin biz var name = "Arda" dediğimizde,IDE otomatik olarak name değişkeninin tipini string set eder,çünkü aldığı değer stringdir.Eğer değişkenimizi bir class içerisinde tanımlıyorsak bir değer ataması yapmamız gerekir.Fakat eğer local olarak bir fonksiyonun içerisinde bir değişken tanımlıyorsak o zaman değişkeninin tipini kesin olarak belirtmemiz gerekir.

fun main() {

var name : String (Bu şekilde başlangıç değer olmadan local bir değişken tanımlayabiliyoruz)

}
class Deneme(){

    val age : Int (Bu şekilde tanımlayamayız,bir değer atamamız gerekir.)

}


--------------------------------------------------------------------------------------------------------------------------------------------------------------------


Q5)Kotlin'de tüm değişkenlerin sınıf olarak bulunması, "ilkel tip" (primitive type) olmadıkları anlamına gelir mi? Arka planda neler oluyor?

Answer5:Kotlinde tüm değişkenler sınıf olarak tutulur, ilgili veri tipinin üzerine ctrl ile tıklayarak bakabiliriz.Fakat bu sınıflar,bytecode'a çevrilirken yapılan özel optimizasyonlarla primitive hallerine dönüştürülürler.Yani aslında kotlinde Int class olarak tutulan veriler,arka planda int olarak tutulur.Bu String hariç bütün değişkenlerde böyledir.String,java tarafında da class halinde tutulur.



--------------------------------------------------------------------------------------------------------------------------------------------------------------------


Q6)"Tip Güvenliği" (Type Safety) kavramını açıklayın.

Answer6:Kotlin'de "type safety" veya "tür güvenliği", bir programın türlerle ilişkili hataları minimuma indirmesini sağlayan bir özelliktir. Bu, kotlinin  tür sistemi tarafından sağlanır ve bizim  veri türlerini doğru ve güvenli bir şekilde kullanılmasını sağlar.Bu aslında bizim kod yazarken daha güvenli ve sağlam kod yazmamızı sağlar.Kotlin,tür güvenliğini çeşitli yollardan sağlar.Null güvenliği,tür çıkarımı,type checks,smart cast gibi özelliklerle kodumuzu minimum hatada yazarız.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------


Q7)Bir değişkeni nullable yapmak için ne yapmalıyız?


Answer7:Kotlinde bir değişkeni nullable yapmak için,değişkenin tipinin sonuna ? koymamız gerekir.Bu,değişkenin null değerini de alabileceği anlamına gelir.Hemen bir örnekle açıklayalım.

fun main() {

    var nullableString : String? = null

}

Yukarıdaki örnekte,nullableString değişkeni string türünde olmasına rağmen null değerini de alabilir çünkü nullable(?) tanımlanmıştır.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------


Q8)"Null Güvenliği" (Null Safety) kavramını açıklayın.

Answer8: Kotlinde bulunan null safety,uygulama geliştirirken null referans hatalarını önlemeyi amaçlayan bir özelliktir.Null referans hataları genellikle bir nesne veya değişken  null olduğunda ya da o nesne veya değişken üzerinden bir işlem yapmaya çalıştığımızda meydana gelir.Bu tür hataları aldığımızda genellikle hata ayıklama süreçlerimiz karmaşıklaşır ve uygulamada beklenmeyen davranışlara yol açabilir.Kotlinde null güvenliğini çeşitli yollardan sağlayabiliriz.Bunlara ?. veya !!. kullanımı,elvis operatörünün kullanımı,let fonksiyonunu kullanımı gibi çeşitli örnekler verilebilir.



--------------------------------------------------------------------------------------------------------------------------------------------------------------------









